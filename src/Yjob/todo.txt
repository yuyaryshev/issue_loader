- Мониторинг базы
    group by
        - project
        - stages

------------------------------------------------------------------------------------------------------------------------
- В Ylog никак не выявляются затраты perfomance на other.
    Нужно брать разницу между perfomance.now() на разных тактах системы. В этой разнице лежит как описанная работа,
    так и other. Нужно научиться как-то отделять их. Например, я подозреваю что все дело в sqlite.


------------------------------------------------------------------------------------------------------------------------
- При запуске Job'а нет возможности его await, а это нужно для тестов.
    Нужно дать эту возможность.
    Вообще нужно уже переделать run таким образом чтобы он возвращал сам job, а не сразу ждал его.
    И вот кода я это сделаю нужно сделать еще и так чтобы Job можно было await'ить и при этом он никогда не выгружался
        - при помощи счетчика promiseLocks.

    Все равно ведь я оборачиваю Job в throwUnload.

- Unloading сделать по-человечески. Собирать массив вообще всех Job'ов и работать уже только с ним.
    Затем - проводить второй цикл, третий и т.п.
    А не как сейчас когда я выгружаю и параллельно идет создание новых Job'ов.

- // WA_DEPS_NOT_WORKING - вместо deps используется stage - удалить всю эту строку после исправления!

- Разделить JobType.run на create и непосредственно run, потому что:
    - Дублеж в JobType.dep и JobType.run
    - Тысячи Job'ов стартуют без зависимостей. Это беда! Нужно использовать preset зависимостей!

- Сделать функции для синхронного связывания observers и deps - они должны обновляться синхронно.
    Это нужно вынести в отдельные функции. Сейчас стремно реализовано см. parent.observers.push([parentContext.id, job.id]);
    Вероятно там все разваливается на разные части...

- JobContextType.open - не достаточно унифицирован. Внутри JobStorage есть отдельные вызовы jobContextById.
    Нужно унифицировать иначе я запутаюсь.



------------------------------------------------------------------------------------------------------------------------
- Нужно сделать отдельную таблицу под связи deps и obervers. Это поможет на БД решать больше важных задач.

- export class JobStatus
    На клиенте RunStatus.jsx
    не синхронен по полям с

    export interface JobStatus
    на сервере

    Из-за этого нет @observable
    А из-за этого - изменения не ловит Mobx
    А из-за этого - не отображается сразу изменение статуса Paused/Resumed

- не обязательно всегда загружать Job из базы, только для того чтобы сбросить его статус
// FUTURE_TEST Убедиться что сравнение не будет выявлять левые поля в итоге постоянно увеличивая и увеличивая историю
- Job никак никогда не удаляются. Это не нормально, должен быть какой-то принцип удаления

------------------------------------------------------------------------------------------------------------------------
Отладка 2020-03-19

-   // TODO раньше, когда тут была массовая ошибка. Система работала Yjob криво - часть job не переходила в transform
    Пока в transform была ошибка часть Job'ов не переходила в stage 02_transform
    Ошибка была вызвана отсутствием dbdJiraIssue в тестовом env.
    Но почти наверняка пойдет любой throw в середине transform
------------------------------------------------------------------------------------------------------------------------
MERGE MERGE MERGE MERGE MERGE MERGE MERGE MERGE MERGE MERGE MERGE MERGE MERGE MERGE MERGE MERGE MERGE MERGE
        // TODO env.globalMessages.sqlite = { status: (!error ? "OK" : "Error"), error };

        - ЧТО: Добавить обработчик exception вокруг sqlite.
            ГДЕ: ?

            Если возник exception - в цикле пробуем каждые 500ms.
            - Пишем в консоль при первом таком событии
            - Пишем в консоль при завершении такого события
            - Добавить env.globalMessages
                - Добавляем в него сообщение когда такое происходит
                - Удаляем из него сообщение когда такое завершается


RELEASE RELEASE RELEASE RELEASE RELEASE RELEASE RELEASE RELEASE RELEASE RELEASE RELEASE RELEASE RELEASE
        - JobStorage
            - При старте - сформировать unloaded счетчики при помощи sql по БД
            - Проверить, что с unloaded waitingTime счетчиками все хорошо

        - Режим bulk-insert JobContext
            ЧТО: Режим bulk-insert JobContext
                - Возможно придется просто сделать insert, а затем уже в спокойном режиме "перерабатывать"
                - Этот режим активируется при создании JobContext
                - Этот режим поддерживается до выхода из стека + 1 стандартный delay jobStorageRegularFunc ИЛИ 300 ms
                - На этом этапе оптимизируется только вставка в базу. Никакие Job'ы не исполняются.
                - Вновь созданные таким образом JobContext пока не включаются в workset, сам workset - не выгружается.
                - Этот режим должен работать в том числе для массового перевода в Stale
                    - Возможно придется просто сделать insert, а затем уже в спокойном режиме "перерабатывать"

        - Защититься от не эффективной загрузки JobContext
            ГДЕ: mainLogic_workset (OLD: В цикле исполнения)
            ЧТО:
                нужно защитится от ситуации, когда я постоянно
                1. Загружаю новый JobContext
                2. Выполняют один Job, который пишет в другой JobContext
                    И в итоге перехожу на (1)

                ЗАЩИТА:
                    - Нужно реализовать workset: Set<JobContext>
                    - Новые задачи в начале забираем из контекстов внутри workset
                    - Если мы прошли весь workset и не нашли ни одной задачи на исполнение
                        То мы очищаем workset и набираем новый workset

        - Реализовать логику externalDeps
            ГДЕ: ?
            ЧТО:
                - Job'ы c external зависимостями не выполняются никогда
                - Вместо этого они вечно ждут того, что сама зависимость исполнится и ее значение будет записано в externalDeps
                    - Это изменит флаг на JobContext который ждет зависимости depsReady => 1
                    - В итоге этот контекст будет загружен
                    - В итоге Job'ы в нем - исполнятся


Потом
    - parentContext_cached - см. поиск по TO_ DO - нужно в этих местах закешировать результат, если требуются запросы между
        контекстами.

    - JobContext_DELETE_COMMENTS
    - CODE00000100`, `unloadException - not implemented!