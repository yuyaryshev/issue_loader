// @ts-ignore

export * from "./Job";
export * from "./JobStep";
export * from "./JobWait";
export * from "./JobStorage";
export * from "./JobType";
export * from "./singletonJob";
export * from "./JobLogItem";
export * from "./JobRetryInterval";
export * from "./awaitDelay";
export * from "./JobFieldsGen";

// Job не должен ожидать других job. Вместо таких await в середине Job должен быть отдельный статус или тот же статус, или предыдущий - не завершаться.
// При этом await в Job всеже будет - я буду ждать внешних событий, например ответа Jira - все это в рамках одного шага Job

/*
        
    Все активные задачи остаются в ActiveSet

    Как хранятся зависимости от других задач?
        В самой задаче - id dependsOn - массив
        В той от которой зависит эта - id dependedJobs - массив

    Как хранятся зависимости от изменения времени?
        Сортировка по времени следующего запуска

?????????????????        
    Как будут запускаться дочерние задачи?
        ! Хранение LOAD_STREAMS и Job должны быть равноправны
            ! Это означает что созданная задача столь же надежна, сколь надежна запись в LOAD_STREAMS
            ! Поэтому LOAD_STREAMS можно и нужно обновлять, когда загружен список Issue, дожидаться выполнения всех fetch-pagination задач не нужно
            - Отсюда следует что лучше бы все эти Job'и тоже хранить в Oracle
        - Регулярно
            - Загружается список новых задач - они загружаются в ISSUE_T
            - Для них создаются Job - не важно в каком они статусе, - все они существуют отдельно
            - Инициализирующую загрузку вообще говоря можно делать путем создания 10к Job по задачам. На этом данную загрузку можно считать завершенной.
                Как выполняются уже сами отдельные задачи - это отдельный вопрос.
                Они же создадут задачи на fetch pagination - это тоже будут отдельные задачи.
                Ключ задачи - важный вопрос - не нужно создавать новые задачи с тем же ключем, задача с одним ключем - всегда одна.
                    Это поможет справится например с тем, что часть Issue не загружаются из-за ошибки - они не существуют.

        ? А точнее - как строятся цепочки из задач?
        То есть например 
            Increment run
                Jira request => Save to DB                        }  
                            => Request pagination1 => Save to DB  } => change increment TS in DB
                            => Request pagination2 => Save to DB  }
                            => Request pagination3 => Save to DB  }

        У меня в голове похоже перемешались две темы: 
            PersistentJob и кеширование запросов.
            Вероятно их не нужно смешивать. Про кеширование стоит подумать отдельно

    - Родительская задача при этом не выходит в следующий этап.
        Вообще говоря я не уверен что вообще родительская задача должна вызываться после отработки дочерних.
        Возможно родительская задача строит граф дочерних задач и после этого - завершается
        Возможно это более понятная схема... А возможно и нет.

    Все не активные задачи складируются в WaitingSet, из ActiveSet - удаляются
        - Есть отдельная функция которая закидывает все задачи из WaitingSet в ActiveSet
        - При сохранении на диск WaitingSet и ActiveSet - не разделяются. Все сохраняется в один список задач

    Что с родительской при ошибке в дочерней
        Дефолтное поведение:
        - Перезапускаем дочернюю задачу
            - Каждый интервал из перечисленных в случае не успеха пробуется три раза
                ["0", "10s", "1m", "3m", "5m", "15m", "30m", "1h", "2h", "12h", "1d", "3d", "5d", "30d"] //
                После этого задача в попытке выполниться будет перезапускаться каждые 30 дней
            - При перезапуске программы данный счетчик
                - НЕ сбрасывается
                - НО в начале добавляется три попытки по 10s
        Альтернатива:
        - [never] - останавливаем задачу и не перезапускаем пока не вмешается разработчик.
        - В общем случае реакция может быть разной. Но я пока не знаю какой - нужны бизнес примеры

*/
